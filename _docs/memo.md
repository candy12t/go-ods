# みんなのデータ構造

## 1章

- インターフェースとその実装との違いを理解することが重要
    - インターフェース(interface)
        - サポートしている操作とその意味を定義
    - 実装(implemenation)
        - データ構造の内部表現と実際に操作を行うアルゴリズムの定義
- Queue
    - 一般的には、FIFOキューを指す
    - add(x) = enqueue(x)
    - remove() = dequeue()
- Priority Queue(優先度付きキュー)
    - 最小の要素を削除する
    - add(x)
    - remove() = deleteMin()
- Stack
    - LIFOキュー
    - add(x) = push(x)
    - remove() = pop()
- Deque
    - FIFOキューとLIFOキューを一般化したインターフェース
    - 双方向キューとも呼ばれる
    - 以下の操作を組み合わせでFIFO,LIFOを実装できる
    - addFirst(x)
    - removeFirst()
    - addLast(x)
    - removeLast()
- List
    - Queue,Stack,DequeはListインターフェースとしてまとめられる
    - 以下の操作を組み合わせてDequeインターフェースを実装できる
    - size()
    - get(i)
    - set(i, x)
    - add(i, x)
    - remove(i)
- USet
    - Unordered Set
    - 数学における集合
    - n個の互いに相違なる要素が含まれる
    - 要素の並び順は決まっていない
    - size()
    - add(x)
    - remove(x)
    - find(x)
- SSet
    - Sorted Set
    - 全順序集合の要素が入る
        - 任意の2つの要素xとyについて大小比較できる集合
    - size()
    - add(x)
    - remove(x)
    - find(x)
    - find(x)は後継探索(successor search)と呼ばれる
    - SSetのfind(x)は実行時間が長くなりがち
    - USetにはないSSetの機能が必要でない限り、Usetを使うほうが良い
- 指数と対数
    - log_b * k = xのとき、b^x = k
    - 底が2の対数を二進対数(binary logarithm)と呼び、底が省略されている場合は二進対数
    - オイラーの定数eを底とする対数の場合は、ln kと表現され、自然対数と呼ぶ
        - 冪指数にある対数の除去
        - 底の変換操作
        - この2つの操作を使うと、自然対数と二進対数の比較ができる
- 階乗
    - n!の大きさはスターリングの近似(Stirling's Approximation)を使って見積もることができる
    - 二項係数は、大きさnの集合における大きさkの部分集合の個数
        - 集合{1,...,n}から相違なるk個の整数を取り出すときの場合の数を表す数
- 漸近記法(asymptotic notation)
- ビッグオー記法
    - コンピュータサイエンス独自の記法ではない
    - アルゴリズムの実行時間の見積もるのに便利
    - nが十分に大きい場合、実行時間が小さいアルゴリズムのほうがどのようなマシンにおいても速い
- 乱択化(randomization)
    - データ構造には乱択化を利用するものがある
    - 格納されているデータや操作に加えて、サイコロの出目も踏まえて実際の処理を決める
    - 同じことをしても実行時間が毎回同じとは限らない
    - データ構造を分析するときは期待実行時間を考えると良い
    - 期待値の最も重要な性質のひとつは**期待値の線形性**である
    - よく使われる手法に**インジケータ確率変数**というものがある
- データ構造の性能を考える重要な項目
    - 正しさ
        - データ構造はそのインターフェースを正しく実装しなければならない
    - 時間計算量
        - データ構造における操作の実行時間は短いほどよい
    - 空間計算量
        - データ構造のメモリ使用量は小さいほどよい
- 実行時間を議論するときは、以下の3種類のいずれかを保証するという話になることが多い
    - 最悪実行時間
        - 最悪実行時間がf(n)のとき、実行時間がf(n)より長くなることは**決して**ない
    - 償却実行時間
        - 償却実行時間がf(n)のとき、典型的な操作にかかるコストがf(n)を超えない
        - いくつかの操作はf(n)より長い時間がかかるかもしれないが、操作の列全体として、1つあたりの実行時間はf(n)
    - 期待実行時間
        - 実行時間が確率変数であり、その確率変数の期待値がf(n)である

## 2章

## 3章

- ポインタを使ったListインターフェースの実装
    - 短所: リストをひとつひとつたどる必要があるため、get(i)やset(i, x)が定数時間ではなくなる
    - 長所: ノードの削除や挿入が定数時間ででき、動的な操作がしやすい
